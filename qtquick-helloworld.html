<html>
    <head>
        <meta charset="utf-8">
        <title>Hallo world with QtQuick 2 and OCaml</title>
        <script src="scripts/jquery-2.0.2.min.js"></script>
        <style type="text/css">
            body {
                font-family: Georgia, Consolas,Helvetica, arial, freesans, clean, sans-serif;
                font-size:  16px;
            }
            .hidden-pre {
                display: none;
            }
        </style>
</head> 
<body>
<h2>QtQuick approach for developing applications</h2>
From release Qt 5.0 well-known Qt Widgets from QtGui have become obsolete and were moved to QtWidgets module. New main GUI toolkit is QtQuick (version 1.0 in Qt < 5.0 and version 2.0 with Qt > 5.0). It allows to create GUI in declarative manner with some Javacript code for simple event handling. The parts of application which are critical for speed should be written in C++.
<p>
Using lablqt we want to avoid writing C++ code to connect OCaml and QtQuick runtime. We want to write only OCaml and QtQuick code (i.e. <code>*.qml</code> files) without any C++.<br/>
<p>
Initially, QtQuick was created for mobile applications, resizable layouts was not supported well and probably it was not a good choice for desktop applications. From version Qt 5.1 module <code>QtQuick.Controls</code> and <code>QtQuick.Layouts</code> are part of Qt. They are a set controls for desktop applications: toolbars, buttons, menus and layouts. They also look native on different plaatforms. Mine first "Hallo world" application will use simple controls from Qt&lt;5.1. In the second I'm going to show you <code>QtQuick.Controls</code>.
<p>
Contents:
<ol>
<li> <a href="#part1">"Hallo world!" in QML</a> </li>
<li> <a href="#part2">Writing OCaml code</a> </li>
<li> <a href="#part3">QtQuick Controls, Layouts and Model/View pattern </a> </li>
<li> <a href="#part4">Defining model in OCaml</a> </li>
</ol>

<h3 id="part1">First QtQuick application</h3>

If we put this to <code>Root.qml</code> we will get a rectangle with text <code>Click me!</code> in its center. After clicking on window text <code>clicked</code> will appear at console.<br/>
<button onclick="$('#code1').toggle();">Show/hide QML script</button> <br/>
<pre id="code1">
import QtQuick 2.0
Rectangle {
    color: "#FFFFDF" // we declare rectangle with custom background color
    width:  400;
    height: 300;     // with custom size
    Text {
        anchors.centerIn: parent
        text: "Click me!"         // text in center of window
    }
    MouseArea {
        anchors.fill: parent      // all space in parent Rectangle will be clickable
        onClicked: console.log("clicked")
    }
}
</pre><br/>
This QML file is already correct application. If you execute it using command <code>qmlscene Root.qml</code> you will get a window like this:<br/><br/>
<center><image src="images/qml1.png"/></center><br/><br/>

At this moment OCaml+QtQuick applications should make startup from C++. So they will share <code>main.cpp</code> file which is entry point to our program. You can copy'n'paste it to your repo. N.B. It uses some headers and external function from OCaml+QtQuick library. We will remember it while compilation<br/>
<button onclick="$('#main_cpp').toggle();">Show/hide main.cpp</button> <br/>
<pre id="main_cpp" class="hidden-pre">
#include "stubs.h"

#include &lt;QtGui/QGuiApplication&gt;
#include &lt;QtQuick/qquickview.h&gt;

void doCaml() {
  CAMLparam0();
  static value *closure = nullptr;
  if (closure == nullptr) {
    closure = caml_named_value("doCamlInitialization");
  }
  Q_ASSERT(closure!=nullptr);
  caml_callback(*closure, Val_unit); // should be a unit
  CAMLreturn0;
}

int main(int argc, char ** argv) {
    caml_main(argv);
    QGuiApplication app(argc, argv);
    QQuickView view;
    view.setResizeMode(QQuickView::SizeRootObjectToView);

    QQmlContext *ctxt = view.rootContext();
    registerContext(QString("rootContext"), ctxt);
    doCaml();
    view.setSource(QUrl::fromLocalFile(QString("Root.qml")));
    view.show();

    return app.exec();
}
</pre><br/>

In <code>main.cpp</code> we do startup initialization on C++ side. Function <code>registerContext</code> exposes Qml context (where global variables are stored) for OCaml. We will refer it using string <code>"rootContext"</code> in <code>program.ml</code> file. Also we call <code>doOCamlInitialization</code> to execute user startup code on OCaml side.
<p>
Let's write this OCaml startup code in <code>program.ml</code><br/>
</p>
<button onclick="$('#program_ml').toggle();">Show/hide program.ml</button> <br/>
<pre id="program_ml">
let main () = print_endline "startup initialiation at OCaml side"
let () = Callback.register "doCamlInitialization" main
</pre>
Using this <code>Makefile</code> you can compile all this sources.
It is not minimal because we will reuse it soon.<br/>
N.B. Don't forget to setup environment for Qt5. I usually do it by modifiing <code>~/.bashrc</code>:
<pre>
export QTDIR=blah/blah/qt5
function with_qt5() {
    export PATH=$QTDIR/qtbase/bin:$PATH
    export PKG_CONFIG_PATH=`qmake -query QT_INSTALL_LIBS`/pkgconfig:$PKG_CONFIG_PATH
    export LD_LIBRARY_PATH=`qmake -query QT_INSTALL_LIBS`:$LD_LIBRARY_PATH
}
</pre>

<button onclick="$('#Makefile').toggle();">Show/hide Makefile</button> <br/>
<pre id="Makefile" class="hidden-pre">
MOC=`qmake -query QT_INSTALL_BINS`/moc
CC=g++ -g -fPIC -std=c++0x `pkg-config --cflags Qt5Core` -I${LABLQT}/qml/lib/_build -I`ocamlc -where` \
   -Dprotected=public -Dprivate=public
CLINK=g++ -g
CLINKLIBS=`pkg-config --libs Qt5Quick`
OUT=main
GEN_CMX=
MOC_CPP=$(addprefix moc_,$(GEN_CMX:.cmx=_c.cpp) )
GEN_CPP=$(GEN_CMX:.cmx=_c.o) $(MOC_CPP:.cpp=.o)
GEN_MOC=$(GEN_CMX:.cmx=_c.cpp)
OCAMLOPT=ocamlfind opt -package compiler-libs.common,unix -linkpkg -g

CMX=program.cmx
CMX_TEST=

.SUFFIXES: .cpp .h .o .ml .cmx .cmo .cmi
.PHONY: all depend clean

all: $(GEN_CMX) $(CMX) $(CMX_TEST) library_code $(GEN_MOC) $(GEN_CPP) main.o
	$(CLINK) -L`ocamlc -where` \
	../lib/_build/stubs.o $(GEN_CPP) camlcode.o main.o -lasmrun \
	-lunix -lcamlstr $(CLINKLIBS) $(NATIVECCLIBS)  -o $(OUT)

depend:
	ocamlfind dep *.ml *.ml > .depend

library_code:
	$(OCAMLOPT) -output-obj -dstartup \
	-I ${LABLQT}/qml/lib/_build ${LABLQT}/qml/lib/_build/qml_wrap.cmxa str.cmxa \
	$(GEN_CMX) $(CMX) -linkall -o camlcode.o #-verbose

moc_%.cpp: %.h
	$(MOC) $< > $@

.cpp.o:
	$(CC) -c $< -I.

.ml.cmx:
	$(OCAMLOPT) -I ${LABLQT}/qml/lib/_build -c $<

clean:
	rm *.o *.cm[oiax] *.cmxa *.o.startup.s $(MOC_CPP) -f

-include  $(shell ocamlc -where)/Makefile.config
include .depend
</pre>

<hr/>
<h3 id="part2">Writing OCaml logic</h3>
And let's create OCaml object which will be exposed to QtQuick engine.
It will have single method <code>onMouseClicked</code> with type <code>string -> unit</code>.
To generate code we will use <code>mocml</code> generator which you will get after compiling in <code>$LABLQT/src</code>. Let's put this to <code>input.json</code> (file name doesn't matter):<br/>
<button onclick="$('#json_file').toggle();" class="hidden-pre">Show/hide generator input file</button> <br/>
<pre id="json_file">
[
{
  "classname": "Controller",
  "methods":
     [ { "name":      "onMouseClicked",
         "signature": ["string", "unit"] }
     ],
  "properties": [],
  "slots": [],
  "signals": []
}
]
</pre>
After executing <code>mocml -qml_wrap input.json</code> three files will be generated: `Controller_c.h`, `Controller_c.cpp` and `Controller.ml`. A part of `Controller.ml` will look like that:
<pre>
class virtual base_Controller cppobj = object(self)
  ...
  method virtual onMouseClicked: string -> unit
end
</pre>
As you see, base class <code>base_Controller</code> is created.
We will inherit it and implement virtual method <code>onMouseClicked</code> in file <code>program.ml:</code>.
<br/>
<button onclick="$('#subclassing').toggle();">Show/hide program.ml</button> <br/>
<pre id="subclassing" class="hidden-pre">
open QmlContext

let main () =
  let controller_cppobj = Controller.create_Controller () in
  let controller = object(self)
    inherit Controller.base_Controller controller_cppobj as super
    method onMouseClicked msg = Printf.printf "OCaml says: '%s'\n%!" msg
  end in
  set_context_property ~ctx:(get_view_exn ~name:"rootContext") ~name:"controller" controller#handler

let () = Callback.register "doCaml" main
</pre>
By executing <code>QmlContext.set_context_property</code> we expose created object for using in QML
with name <code>"controller"</code>. Now we can use it there:
<pre>
MouseArea {
    anchors.fill: parent      // all space in parent Rectangle will be clickable
    onClicked: controller.onMouseClicked("message");
}
</pre>
Also we need to put into Makefile information about generated files. We need to add new target to <code>GEN_CMX</code>:
<pre>
GEN_CMX=Controller.cmx
</pre>
After executing program when you will click on window you will se console output.

<p>
Code of this example you can find <a href="https://github.com/Kakadu/lablqt/tree/qml-dev/qml/halloworld">there</a>.
</p>

<h3 id="part3">QtQuick Controls, Layouts and Model/View pattern</h3>
Since Qt version 5.1 it easy to create desktop applications which look like native. API documentaion can be found 
<a href="http://doc-snapshot.qt-project.org/qt5-stable/qtquickcontrols/qtquickcontrols-index.html">there</a> and 
<a href="http://doc-snapshot.qt-project.org/qt5-stable/qtquicklayouts/qtquicklayouts-index.html">there</a>.
<br/>
<button onclick="$('#menus').toggle();">Show/hide QML menus</button> <br/>
<pre id="menus" class="hidden-pre">
ApplicationWindow {
    width: 1366
    height: 768
    menuBar: MenuBar {
        Menu {
            title: "Edit"

            MenuItem {
                text: "Cut";    shortcut: "Ctrl+X";
                onTriggered: console.log("")
            }
            MenuItem {
                text: "Copy";   shortcut: "Ctrl+C"
                onTriggered: console.log("")
            }
            MenuItem {
                text: "Paste";  shortcut: "Ctrl+V"
                onTriggered: console.log("")
            }
        }
    }
    ....
}
</pre>
ToolBars are supported too:<br/>
<button onclick="$('#toolbars').toggle();">Show/hide QML toolbars</button> <br/>
<pre id="toolbars" class="hidden-pre">
    toolBar: ToolBar {
        RowLayout {
            anchors.margins: 8
            anchors.fill: parent
            ToolButton {
                text: "Press me"
                onClicked: console.log("Press me clicked")
            }
        }
    }
</pre>
QtQuick uses Model/View pattern for creating views. I.e. when you create a view you should provide an object with data (model) and a way to render it. Models can be created both in QML file and in C++. Let's create a model with QML:<br/>
<button onclick="$('#qml_models').toggle();">Show/hide QML models</button> <br/>
<pre id="qml_models">
    ListModel {
        id: libraryModel
        ListElement{ title: "A Masterpiece" ; author: "Gabriel" }
        ListElement{ title: "Brilliance"    ; author: "Jens" }
        ListElement{ title: "Outstanding"   ; author: "Frederik" }
    }
</pre>
It is a ListModel with three elements. Each element has two properties of type <code>string</code>: title and author. We will use them while declaring view for this model:<br/>
<button onclick="$('#qml_tableview1').toggle();">Show/hide QML table view</button> <br/>
<pre id="qml_tableview1">
    TableView {
        model: libraryModel
        anchors.fill: parent

        TableViewColumn { title: "Title";  role: "title"  }
        TableViewColumn { title: "Author"; role: "author" }
    }
</pre>
You can see there a table view with two columns. Each column have header title: "Title" and "Author" respectivly.  Elements of this table will be constructed according to its model object (if the model is a list of three elements the three item in view will be constructed). 
<p>
Screenshot there:<br/>
<center><image src="images/QtQuickControls1.png"/></center><br/><br/>

P.S. All works great but while implementing QtQuick.Controls developers have added some restrictions on startup C++ file. This one will work OK: <br/>
<button onclick="$('#main_cpp2').toggle();">main.cpp for QtQuick.Controls</button> <br/>
<pre id="main_cpp2">
int main(int argc, char ** argv) {
    caml_main(argv);
    QApplication app(argc, argv);

    QQmlEngine engine;
    QQmlComponent component(&engine);

    QQmlContext *ctxt = engine.rootContext();
    registerContext(QString("rootContext"), ctxt);
    doCaml();

    component.loadUrl(QUrl("Root.qml"));
    QObject *topLevel = component.create();
    QQuickWindow *window = qobject_cast&lt;QQuickWindow*&gt;(topLevel);

    window->show();

    return app.exec();
}</pre>

<h3 id="part4">Defining model in OCaml</h3>
Often we want dynamic models which will report to view about newly added rows, columns and data changes. In Qt world it is achieved by defining model in C++ as a sublclass of <code>QAbstractItemModel</code>. We also have special option in JSON which subclasses generated object from <code>QAbstractItemModel</code> automatically.
<pre>
{
    "classname": "MainModel",
    "basename":  "QAbstractItemModel",
    "methods": [],
    "properties": [],
    "slots": [],
    "signals": []
}
</pre>
Our model will provide access to objects which have two properties: <code>author</code> and <code>title</code>. We will call it <code>DataItem</code> and put into <code>input.json</code> too.<br/>
<pre>
{
    "classname": "DataItem",
    "methods": [],
    "properties":
      [ { "name":      "author",
          "get":       "author",
          "set":       "setName",
          "notify":    "nameChanged",
          "type":      "string" }
      , { "name":      "title",
          "get":       "title",
          "set":       "setTitle",
          "notify":    "titleChanged",
          "type":      "string" }
      ],
    "slots": [],
    "signals": []
}
</pre>
Don't forget to add <code>GEN_CMX=MainModel.cmx DataItem.cmx</code> to compile generated files.
<p>
Let's define out model and expose it to QtQuick engine in initialization block of <code>program.ml</code>. Initial data will be a list of pairs title/author
<pre>
  let data =
    [ ("Анна Керенина",           "Лев Толстой")
    ; ("Война и Мир",             "Лев Толстой")
    ; ("Les Misérables",          "Victor Hugo")
    ; ("Les Trois Mousquetaires", "Alexandre Dumas, père")
    ] in
</pre>
Using it we need to construct DataItems:
<pre>
  let dataItems = List.map (fun (title,author) ->
    let cppobj = DataItem.create_DataItem () in
    object
      inherit DataItem.base_DataItem cppobj as super
      method author () = author
      method title () = title
    end
  ) data in
</pre>
Generated MainModel class gas many virtual methods. We need only 1-dimensional model, that's why some methods has very simple implementation
<pre>
  let model_cppobj = MainModel.create_MainModel () in
  MainModel.add_role model_cppobj 555 "someRoleName";

  let model = object(self)
    inherit MainModel.base_MainModel model_cppobj as super
    method parent _ = QModelIndex.empty
    method columnCount _ = 1
    method index row column parent =
      if (row>=0 && row<self#rowCount parent) then QModelIndex.make ~row ~column:0
      else QModelIndex.empty
    method hasChildren _ = self#rowCount QModelIndex.empty > 0
    method rowCount _ = List.length dataItems
</pre>
In method <code>data</code> we will return dataItem from our list if role of element is OK (<b>TODO: add link to Qt documentation about roles</b>).
<pre>
    method data index role =
      let r = QModelIndex.row index in
      if (r<0 || r>= List.length data) then QVariant.empty
      else begin
        match role with
          | 0 | 555 -> QVariant.of_object (List.nth dataItems r)#handler
          | _ -> QVariant.empty
      end
  end in
  set_context_property ~ctx:(get_view_exn ~name:"rootContext") ~name:"mainModel" model#handler
</pre>
And if model of our TableView is <code>mainModel</code> we will get something like this: <br/>
<center><image src="images/QtQuickControls2.png"/></center><br/><br/>

</body>
</html>
