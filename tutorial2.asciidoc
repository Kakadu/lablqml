:imagesdir: ./images/tutorial2

QtQuick approach for developing applications
============================================
Dmitrii Kosarev aka Kakadu ("kakadu.hafanana" ^ "@" ^ "gmail.com")

N.B.
---
This tutorial is 2nd tutorial about OCaml and QtQuick. You can get old one link:tutorial.html[here].
With `lablqt 0.3` we don't need JSON file to describe interface between QtQuick and OCaml, this approach was replaced by PPX extension. So, `lablqt 0.3` requires OCaml 4.02 or newer.

This tutorial is not finished yet, I'm working on it.


About
-----
In this tutorial we will see how to create simple QtQuick applications and how they will communicate with OCaml. QtQuick code will be very short because this tutorial is about using OCaml and QtQuick together. If you want to get more informations about programming in QtQuick you can visit link:https://qt-project.org/doc/qt-5/qtquick-index.html[official help] or link:http://qmlbook.org/[QML book].

Getting Qt5
-----------
Using package repository
~~~~~~~~~~~~~~~~~~~~~~~~
There is Qt 5.2.1 in Ubuntu Trusty and Qt5.3 in current Debian/testing (July 1, 2014). I have got Qt 5.3 using official installer but all code should work with Qt 5.2 too. If it doesn't, please report me somehow.

Official packages
~~~~~~~~~~~~~~~~~
are available on https://download.qt-project.org/official_releases/qt/5.3/5.3.0/[Qt Project]. I'm using this one.

Building from Git
~~~~~~~~~~~~~~~~~
Official Qt Project wiki is
http://qt-project.org/wiki/Building_Qt_5_from_Git[there]. Below you
can see `my-init` and `configure` scripts which configure
Qt5 to build only modules needed by lablqt.

.My init-repository script
----
$ cat my-init
#!/usr/bin/env bash
MODULES=qtbase,qtdeclarative,qtjsbackend,qtactiveqt,qtquickcontrols
perl ./init-repository --module-subset=$MODULES -f $@
----

.My configure script
----
$ cat my-configure
#!/bin/bin/env bash
set -x
./configure -developer-build -opensource -nomake examples -nomake tests -confirm-license \
  -no-gtkstyle -no-glib -no-cups  $@
----

Qt compiles some code during `./configure` stage, don't worry, it's
normal.

Compilation time depends on your machine. Some fellas have finished with `-j8` in 5 minutes. On my Intel Core i3 I can do it with `-j2` in 30 minutes.

.P.S.
I have discovered some issues with compilation my QOCamlBrowser app recently on Ubuntu 13.10 32bit on Intel Core 2 Duo CPU. My application was crashing in `qt_memfill32_sse2 (dest=0x8910e10, value=0, count=194)` at `painting/qdrawhelper_sse2.cpp:264`. So, I have decided to disable special instruction sets for Qt5 on this machine by improving `./my-configure` script. I put this stuff in `P.S.` section because I haven't tested it on my Intel i3 machine.
----
#!/usr/bin/env bash
set -x
NOFB="-no-directfb -no-linuxfb -no-eglfs -no-kms"
SQL="-no-sql-mysql -no-sql-sqlite"
NOSSE="-no-sse2 -no-sse3 -no-ssse3 -no-sse4.1 -no-sse4.2 -no-avx -no-avx2"
./configure -developer-build -opensource -nomake examples -nomake tests -confirm-license \
  -no-gtkstyle -no-glib -no-cups -no-nis \
  $SQL $NOFB $NOSSE \
  $@
----

Value `$NOFB` disables framebuffer and KMS support. I think these low-level interfaces are not needed for our OCaml GUI projects. Also we disable SQLite and MySQL DBMS in Qt. Value `$NOSSE` disables all special instruction sets.With that `./my-configure` QtQuick examples in Qt still work and my QOcamlBrowser startups without crash.

If you want to compile Qt faster you can study next options of `./configure script`:

----
    -no-feature-<feature> Do not compile in <feature>.
    -feature-<feature> .. Compile in <feature>. The available features
                          are described in src/corelib/global/qfeatures.txt
----

.P.P.S. MacOS remark

Mac users can consider invoking configure using `./configure -prefix /opt/Qt/5.2.1 -opensource -nomake tests -no-xcb -no-framework`. I can't test that but some fellas https://github.com/Kakadu/lablqt/issues/16[can].

.P.P.P.S.

Next script will be useful (as a part of `~/.bashrc`) for setting local environment for your Qt5 build:

----
with_qt5() {
  export PATH=~/mand/prog/qt/qt5/qtbase/bin:$PATH  # where Qt5 has been build
  qmake -query QT_VERSION
  export LD_LIBRARY_PATH=`qmake -query QT_INSTALL_LIBS`:$LD_LIBRARY_PATH
  export PKG_CONFIG_PATH=`qmake -query QT_INSTALL_LIBS`/pkgconfig:$PKG_CONFIG_PATH
}
----

[[hello_world]]
"Hello world!" in QtQuick
-------------------------

Demos described below and sources of this tutorial can be found in Github link:github.com/Kakadu/lablqt/tree/gh-pages/demos/0.2[repository].

In piece of code below we create application's window, a colored area at the top and some text centered in it. Some properties of root window are set. Position of inner rectangle is described using link:http://qmlbook.org/ch04/index.html#positioning-elements[anchors].

----
include::demos/0.3/demo1.qml[]

----

This QML file is already correct application. If you execute it using command `qmlscene Root.qml` you will get a window like this:

image:img1.png[]

Normal way to interact between QtQuick and C++ is exposing some objects into QtQuick engine. We will do the same but we will describe this object's class in OCaml using PPX extension. Build system will help us to compile all into final executable. Let's describe class `controller` in `controller.ml`:

----
include::demos/0.3/controller1.ml[]

----

Module `QmlContext` can be found in ocamlfind package named `lablqml`. This package and PPX extension named `ppx_qt` are located in OPAM's package `lablqt` with version 0.3. To apply syntax extension on this file you need to execute following commmand:

----
ocamlopt -I `ocamlfind query lablqml` -c -dsource -ppx "../ppx_qt -destdir . -ext cpp" controller.ml
----

In `controller.ml` you can see class `controller` with attribute `qtclass` and its method `onMouseClicked` with attribute `qtmeth`. Without this attributes class and method will not be available in QtQuick.

After preprocessing source file we will get a virtual class called `controller` with virtual method `onMouseClicked` which should be implemented. Let's do this in `program.ml`

----
include::demos/0.3/demo1/program.ml[]
----

We have created new object with method `onMouseClicked` which prints something to stdout. This object was exposed to QtQuick engine with name `controller`. After that application was started in function `run_with_QQmlApplicationEngine`, It takes initialization callback and QML file to be opened as main QML file. Path to QML file is relative but you can embed QMLs into executable using http://qt-project.org/doc/qt-5.0/qtcore/resources.html[Qt Resource System].

.QtQuick and QML
****
QtQuick and QML are very similar concepts and can replace each other. In Qt Modeling Language (QML) we describe user interface and store it in files with `qml` extension. QtQuick is a number of classes from which GUI can built.
****

Our QtQuick file doesn't know anything about exposed object yet. So, let's create some area which will receive mouse events and call OCaml if is was clicked.

----
include::demos/0.3/demo1/Root.qml[]
----

.Where should we start-up from?
****
Our applications can do startup from both OCaml and C\+\+. Example above starts up from OCaml. See http:github.com/Kakadu/lablqt/tree/gh-pages/demos/0.2[demos] from previous tutorial to get examples of startup from C++.
****

Full code of first demo is available on https://github.com/Kakadu/lablqt/tree/gh-pages/demos/0.3/demo1[github].

[[properties]]
Qt object's metamodel
---------------------

In Qt classes based on `QObject` can have _properties_, _signals_, _slots_ and methods _invokable_ from QtQuick. All information about this stuff is generated from C++ header files during compilation phase.

For example, our method `onMouseClicked` declared above is invokable, that's why we can use it from QML. In contrary we will get type error:
----
Property 'onMouseClicked' of object controller(0x153cd00) is not a function
----

Properties always have name, type, method which can read value of property. They can have method to be set by (usually it is called _setter_), properties are read-only otherwise. When property changes it can send _signal_ saying which new value of property is.

_Signals_ usually are _connected_ with _slots_. For example:
----
auto listener = new PortListener();
auto parser = new MessageParser();
connect(listener, SIGNAL(gotData(QByteArray)), parser, SLOT(onDataReceived(QByteArray)) );
----

As you can see relation between object is instantiated independently from them, i.e. object's classes are independent: we don't need to think about passing callbacks or creating some heavy-weight design patterns. These is Qt's way to avoid dependecy injection.

[[properties]]
Adding properties
-----------------

Let's extend first demo by counting how many times we have clicked on the window. We will do it by declaring a prperty of type `int`. To do this we need to improve our class definition in `controller.ml`:

----
include::demos/0.3/demo2/controller.ml[]
----
To count how many times we clicked we need additional variable available in class. We will add it into `program.ml`:

----
include::demos/0.3/demo2/program.ml[]
----

If user clicks by mouse we will increment counter and emit signal with new counter value using method `emit_$(PROPERTY_NAME)Changed`. Without emitting a signal QtQuick will not know that value has been changed and will use old one. How exactly QtQuick will use it we declare in `Root.qml`. We add new rectangle with text in it which show how many times we clicked. In this demo we also use QtQuick https://qt-project.org/doc/qt-5/qtquicklayouts-overview.html[layout] to place rectangles vertically. We will not use anchors to implement it.

----
include::demos/0.3/demo2/Root.qml[]
----

Our property is used in line
----
text: "You have clicked " + controller.clicksCount + " times"
----

Right side (after colon character) should be valid ECMAScript expression which is evaluted into property value. It can be multiline, call some functions and methods and use many properties inside. When one of properties is changed all expression is evaluated and `text` property gets new value.

Sources of this demo can be found on https://github.com/Kakadu/lablqt/tree/gh-pages/demos/0.3/demo2[github]. Final window should be like on this picture:

image:img2.png[title]

[[signals]]
Adding signals
--------------

When we declare a property signal for notification about changes is added automatically. We can also declare a signal manually using the same PPX syntax extension.

----
include::demos/0.3/demo3/controller.ml[]
----

And we need to connect signal `hiGotten` with some handler in QtQuick:

----
Connections {
    target: controller
    onHiGotten: console.log(message)
}
----

The `on` prefix is a syntax convention to declare signal handlers. Arguments of signal (the `message` in our example) are available without any use code. It means that Qt infer them from signal declaration. If we will declare signal in OCaml side without labels Qt will not be able to get signal's arguments' names. That's why should declare signals using labeled arguments.

Syntax extension is expanded into method `emit_$(SIGNAL_NAME)`. We can use it in `program.ml`.

----
include::demos/0.3/demo3/program.ml[]
----

Full code of this demo is available on https://github.com/Kakadu/lablqt/tree/gh-pages/demos/0.3/demo3[github].


[[signals]]
Supported types
---------------

TODO:





[[views]]
Not described stuff
-------------------

TODO:

Since Qt version 5.1 it easy to create desktop applications which look like native. API documentaion can be found http://doc-snapshot.qt-project.org/qt5-stable/qtquickcontrols/qtquickcontrols-index.html[there] and http://doc-snapshot.qt-project.org/qt5-stable/qtquicklayouts/qtquicklayouts-index.html[there].

.Menus with QtQuick Controls
----
ApplicationWindow {
    width: 1366
    height: 768
    menuBar: MenuBar {
        Menu {
            title: "Edit"

            MenuItem {
                text: "Cut";    shortcut: "Ctrl+X";
                onTriggered: console.log("")
            }
            MenuItem {
                text: "Copy";   shortcut: "Ctrl+C"
                onTriggered: console.log("")
            }
            MenuItem {
                text: "Paste";  shortcut: "Ctrl+V"
                onTriggered: console.log("")
            }
        }
    }
    ....
}
----
.ToolBars are supported too
----
    toolBar: ToolBar {
        RowLayout {
            anchors.margins: 8
            anchors.fill: parent
            ToolButton {
                text: "Press me"
                onClicked: console.log("Press me clicked")
            }
        }
    }
----
QtQuick uses Model/View pattern for creating views. I.e. when you
                create a view you should provide an object with data
                (model) and a way to render it. Models can be created
                both in QML file and in C++. Let's create a model with
                QML:

.Simple model for TableView
----
    ListModel {
        id: libraryModel
        ListElement{ title: "A Masterpiece" ; author: "Gabriel" }
        ListElement{ title: "Brilliance"    ; author: "Jens" }
        ListElement{ title: "Outstanding"   ; author: "Frederik" }
    }
----
It is a ListModel with three elements. Each element has two properties of type string: title and author. We will use them while declaring view for this model:

.Simple TableView example
----
    TableView {
        model: libraryModel
        anchors.fill: parent

        TableViewColumn { title: "Title";  role: "title"  }
        TableViewColumn { title: "Author"; role: "author" }
    }
----
You can see there a table view with two columns. Each column have header title: "Title" and "Author" respectivly. Elements of this table will be constructed according to its model object (if the model is a list of three elements the three item in view will be constructed).
Screenshot there: image:images/QtQuickControls1.png[title]

[[datamodels]]
Defining model in OCaml
-----------------------
Often we want dynamic models which will report to view about newly added rows, columns and data changes. In Qt world it is achieved by defining model in C++ as a sublclass of `QAbstractItemModel`. More information in this topic you can get at Qt Project.
We also have special option in JSON which subclasses generated object from
http://qt-project.org/doc/qt-5.0/qtcore/qabstractitemmodel.html[QAbstractItemModel]
automatically.

.Input file mocml with model class defined
----
{
    "classname": "MainModel",
    "basename":  "QAbstractItemModel",
    "methods": [],
    "properties": [],
    "slots": [],
    "signals": []
}
----
Our model will provide access to objects which have two properties:
    author and title. We will call it DataItem and put into input.json
    too.

.Input file for mocml with data object definition
----
{
    "classname": "DataItem",
    "methods": [],
    "properties":
      [ { "name":      "author",
          "get":       "author",
          "set":       "setName",
          "notify":    "nameChanged",
          "type":      "string" }
      , { "name":      "title",
          "get":       "title",
          "set":       "setTitle",
          "notify":    "titleChanged",
          "type":      "string" }
      ],
    "slots": [],
    "signals": []
}
----

Now let's define out model and expose it to QtQuick engine in initialization block of program.ml. Initial data will be a list of pairs title/author:

----
  let data =
    [ ("Анна Каренина",           "Лев Толстой")
    ; ("Война и Мир",             "Лев Толстой")
    ; ("Les Misérables",          "Victor Hugo")
    ; ("Les Trois Mousquetaires", "Alexandre Dumas, père")
    ] in
----

Using it we need to construct DataItems:

----
  let dataItems = List.map (fun (title,author) ->
    let cppobj = DataItem.create_DataItem () in
    object
      inherit DataItem.base_DataItem cppobj as super
      method author () = author
      method title () = title
    end
  ) data in
----

Generated MainModel class has many virtual methods. We need only
    1-dimensional model, that's why some methods has very simple
    implementation

----
  let model_cppobj = MainModel.create_MainModel () in
  MainModel.add_role model_cppobj 555 "someRoleName";

  let model = object(self)
    inherit MainModel.base_MainModel model_cppobj as super
    method parent _ = QModelIndex.empty
    method columnCount _ = 1
    method index row column parent =
      if (row>=0 && row self#rowCount parent) then QModelIndex.make ~row ~column:0
      else QModelIndex.empty
    method rowCount _ = List.length dataItems
    ...
----

In method data we will return dataItem from our list if role of
    element is OK. Magic number 555 appears because we are defining
    user role for model.

----
    ...
    method data index role =
      let r = QModelIndex.row index in
      if (r<0 || r>= List.length data) then QVariant.empty
      else begin
        match role with
          | 0 | 555 -> QVariant.of_object (List.nth dataItems r)#handler
          | _ -> QVariant.empty
      end
  end in
  set_context_property ~ctx:(get_view_exn ~name:"rootContext")
    ~name:"mainModel" model#handler
----
And if model of our TableView is mainModel we will get something like
    this: image:images/QtQuickControls2.png[title]


////
The First Section
-----------------
Article sections start at level 1 and can be nested up to four levels
deep.
footnote:[An example footnote.]
indexterm:[Example index entry]

And now for something completely different: ((monkeys)), lions and
tigers (Bengal and Siberian) using the alternative syntax index
entries.
(((Big cats,Lions)))
(((Big cats,Tigers,Bengal Tiger)))
(((Big cats,Tigers,Siberian Tiger)))
Note that multi-entry terms generate separate index entries.

Here are a couple of image examples: an image:images/smallnew.png[]
example inline image followed by an example block image:
////

////
[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.
////

ifdef::backend-docbook[]
[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
endif::backend-docbook[]
